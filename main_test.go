package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/gorilla/websocket"
)

// ==================== Helper Functions ====================

func setupTestServer(t *testing.T) (*Server, string) {
	t.Helper()
	dataDir, err := os.MkdirTemp("", "rikugan-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	server := NewServer(0, dataDir, "test-admin-token", "test-agent-token")
	return server, dataDir
}

func cleanupTestServer(t *testing.T, dataDir string) {
	t.Helper()
	os.RemoveAll(dataDir)
}

func makeAdminRequest(t *testing.T, server *Server, method, path string, body interface{}) *httptest.ResponseRecorder {
	t.Helper()
	var reqBody io.Reader
	if body != nil {
		jsonBody, _ := json.Marshal(body)
		reqBody = bytes.NewReader(jsonBody)
	}

	req := httptest.NewRequest(method, path, reqBody)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	req.Header.Set("Content-Type", "application/json")

	rr := httptest.NewRecorder()
	return rr
}

// ==================== Token Generation Tests ====================

func TestGenerateToken(t *testing.T) {
	token1 := generateToken()
	token2 := generateToken()

	if len(token1) != 64 {
		t.Errorf("Token should be 64 hex chars, got %d", len(token1))
	}

	if token1 == token2 {
		t.Error("Tokens should be unique")
	}

	// Verify it's valid hex
	for _, c := range token1 {
		if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {
			t.Errorf("Invalid hex character in token: %c", c)
		}
	}
}

// ==================== ISO 8601 Time Tests ====================

func TestNowISO8601(t *testing.T) {
	timestamp := nowISO8601()

	// Should be parseable
	parsed, err := parseISO8601(timestamp)
	if err != nil {
		t.Errorf("Failed to parse ISO8601 timestamp: %v", err)
	}

	// Should be recent (within last second)
	if time.Since(parsed) > time.Second {
		t.Error("Timestamp is not recent")
	}

	// Should contain expected format elements
	if !strings.Contains(timestamp, "T") || !strings.Contains(timestamp, "Z") {
		t.Errorf("Timestamp doesn't look like ISO8601: %s", timestamp)
	}
}

func TestParseISO8601(t *testing.T) {
	testCases := []struct {
		input    string
		wantErr  bool
	}{
		{"2024-01-15T10:30:00Z", false},
		{"2024-12-31T23:59:59Z", false},
		{"invalid", true},
		{"2024-01-15", true},
	}

	for _, tc := range testCases {
		_, err := parseISO8601(tc.input)
		if (err != nil) != tc.wantErr {
			t.Errorf("parseISO8601(%q): got err=%v, wantErr=%v", tc.input, err, tc.wantErr)
		}
	}
}

// ==================== Server Initialization Tests ====================

func TestNewServer(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	if server.config.AdminToken != "test-admin-token" {
		t.Errorf("Admin token not set correctly")
	}

	if server.config.AgentToken != "test-agent-token" {
		t.Errorf("Agent token not set correctly")
	}

	// Check sync directory was created
	syncDir := filepath.Join(dataDir, "sync")
	if _, err := os.Stat(syncDir); os.IsNotExist(err) {
		t.Error("Sync directory was not created")
	}
}

func TestNewServerAutoGeneratedTokens(t *testing.T) {
	dataDir, _ := os.MkdirTemp("", "rikugan-test-*")
	defer os.RemoveAll(dataDir)

	server := NewServer(8080, dataDir, "", "")

	if len(server.config.AdminToken) != 64 {
		t.Errorf("Auto-generated admin token should be 64 chars, got %d", len(server.config.AdminToken))
	}

	if len(server.config.AgentToken) != 64 {
		t.Errorf("Auto-generated agent token should be 64 chars, got %d", len(server.config.AgentToken))
	}

	if server.config.AdminToken == server.config.AgentToken {
		t.Error("Admin and agent tokens should be different")
	}
}

// ==================== Command Persistence Tests ====================

func TestCommandPersistence(t *testing.T) {
	dataDir, _ := os.MkdirTemp("", "rikugan-test-*")
	defer os.RemoveAll(dataDir)

	// Create server and add command
	server1 := NewServer(0, dataDir, "admin", "agent")
	cmd := Command{
		ID:          "test-cmd-1",
		Command:     "echo hello",
		IntervalSec: 60,
		OS:          "linux",
		CreatedAt:   nowISO8601(),
	}

	server1.commandsMu.Lock()
	server1.commands[cmd.ID] = cmd
	server1.commandsMu.Unlock()
	server1.saveCommands()

	// Create new server instance (simulating restart)
	server2 := NewServer(0, dataDir, "admin", "agent")

	server2.commandsMu.RLock()
	loadedCmd, exists := server2.commands["test-cmd-1"]
	server2.commandsMu.RUnlock()

	if !exists {
		t.Fatal("Command was not persisted across restart")
	}

	if loadedCmd.Command != "echo hello" {
		t.Errorf("Command text not preserved: got %q", loadedCmd.Command)
	}

	if loadedCmd.IntervalSec != 60 {
		t.Errorf("Interval not preserved: got %d", loadedCmd.IntervalSec)
	}

	if loadedCmd.OS != "linux" {
		t.Errorf("OS not preserved: got %q", loadedCmd.OS)
	}
}

// ==================== Admin Authentication Tests ====================

func TestAdminAuthMiddleware(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	handler := server.adminAuth(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("success"))
	})

	testCases := []struct {
		name       string
		authHeader string
		queryParam string
		wantStatus int
	}{
		{"Valid header auth", "Bearer test-admin-token", "", http.StatusOK},
		{"Valid query auth", "", "test-admin-token", http.StatusOK},
		{"Invalid token", "Bearer wrong-token", "", http.StatusUnauthorized},
		{"No auth", "", "", http.StatusUnauthorized},
		{"Empty bearer", "Bearer ", "", http.StatusUnauthorized},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			path := "/test"
			if tc.queryParam != "" {
				path += "?admin_token=" + tc.queryParam
			}

			req := httptest.NewRequest("GET", path, nil)
			if tc.authHeader != "" {
				req.Header.Set("Authorization", tc.authHeader)
			}

			rr := httptest.NewRecorder()
			handler(rr, req)

			if rr.Code != tc.wantStatus {
				t.Errorf("Got status %d, want %d", rr.Code, tc.wantStatus)
			}
		})
	}
}

// ==================== Commands API Tests ====================

func TestHandleCommandsGet(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Add some commands
	server.commandsMu.Lock()
	server.commands["cmd1"] = Command{ID: "cmd1", Command: "echo 1", IntervalSec: 60, OS: "linux"}
	server.commands["cmd2"] = Command{ID: "cmd2", Command: "echo 2", IntervalSec: 120, OS: "windows"}
	server.commandsMu.Unlock()

	req := httptest.NewRequest("GET", "/api/commands", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusOK)
	}

	var commands []Command
	if err := json.NewDecoder(rr.Body).Decode(&commands); err != nil {
		t.Fatalf("Failed to decode response: %v", err)
	}

	if len(commands) != 2 {
		t.Errorf("Got %d commands, want 2", len(commands))
	}
}

func TestHandleCommandsPost(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	newCmd := map[string]interface{}{
		"command":      "df -h",
		"interval_sec": 300,
		"os":           "linux",
	}
	body, _ := json.Marshal(newCmd)

	req := httptest.NewRequest("POST", "/api/commands", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer test-admin-token")
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	if rr.Code != http.StatusCreated {
		t.Errorf("Got status %d, want %d. Body: %s", rr.Code, http.StatusCreated, rr.Body.String())
	}

	var created Command
	if err := json.NewDecoder(rr.Body).Decode(&created); err != nil {
		t.Fatalf("Failed to decode response: %v", err)
	}

	if created.Command != "df -h" {
		t.Errorf("Command not set correctly: got %q", created.Command)
	}

	if created.ID == "" {
		t.Error("ID should be auto-generated")
	}

	if created.CreatedAt == "" {
		t.Error("CreatedAt should be set")
	}

	// Verify it's stored
	server.commandsMu.RLock()
	_, exists := server.commands[created.ID]
	server.commandsMu.RUnlock()

	if !exists {
		t.Error("Command was not stored")
	}
}

func TestHandleCommandsPostWithCustomID(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	newCmd := map[string]interface{}{
		"id":           "my-custom-id",
		"command":      "hostname",
		"interval_sec": 60,
	}
	body, _ := json.Marshal(newCmd)

	req := httptest.NewRequest("POST", "/api/commands", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer test-admin-token")
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	var created Command
	json.NewDecoder(rr.Body).Decode(&created)

	if created.ID != "my-custom-id" {
		t.Errorf("Custom ID not preserved: got %q", created.ID)
	}
}

func TestHandleCommandsPostDefaultOS(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	newCmd := map[string]interface{}{
		"command":      "echo test",
		"interval_sec": 60,
		// OS not specified
	}
	body, _ := json.Marshal(newCmd)

	req := httptest.NewRequest("POST", "/api/commands", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer test-admin-token")
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	var created Command
	json.NewDecoder(rr.Body).Decode(&created)

	if created.OS != "all" {
		t.Errorf("Default OS should be 'all', got %q", created.OS)
	}
}

func TestHandleCommandsDelete(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Add a command first
	server.commandsMu.Lock()
	server.commands["to-delete"] = Command{ID: "to-delete", Command: "echo delete me"}
	server.commandsMu.Unlock()

	req := httptest.NewRequest("DELETE", "/api/commands?id=to-delete", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusOK)
	}

	// Verify deletion
	server.commandsMu.RLock()
	_, exists := server.commands["to-delete"]
	server.commandsMu.RUnlock()

	if exists {
		t.Error("Command should have been deleted")
	}
}

func TestHandleCommandsDeleteMissingID(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	req := httptest.NewRequest("DELETE", "/api/commands", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	if rr.Code != http.StatusBadRequest {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusBadRequest)
	}
}

// ==================== Agents API Tests ====================

func TestHandleAgentsGet(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Add some agents
	server.agentsMu.Lock()
	server.agents["agent1"] = &Agent{
		ID:          "agent1",
		OS:          "linux",
		ConnectedAt: "2024-01-15T10:00:00Z",
		LastSeen:    "2024-01-15T10:30:00Z",
		Connected:   true,
	}
	server.agents["agent2"] = &Agent{
		ID:          "agent2",
		OS:          "windows",
		ConnectedAt: "2024-01-15T09:00:00Z",
		LastSeen:    "2024-01-15T09:30:00Z",
		Connected:   false,
	}
	server.agentsMu.Unlock()

	req := httptest.NewRequest("GET", "/api/agents", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleAgents)(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusOK)
	}

	var agents []map[string]interface{}
	if err := json.NewDecoder(rr.Body).Decode(&agents); err != nil {
		t.Fatalf("Failed to decode response: %v", err)
	}

	if len(agents) != 2 {
		t.Errorf("Got %d agents, want 2", len(agents))
	}

	// Check that sensitive fields (conn) are not exposed
	for _, agent := range agents {
		if _, exists := agent["conn"]; exists {
			t.Error("WebSocket connection should not be exposed in API")
		}
	}
}

// ==================== Files API Tests ====================

func TestHandleFilesGet(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Create some test files
	testFile1 := filepath.Join(server.syncDir, "test1.sh")
	testFile2 := filepath.Join(server.syncDir, "test2.txt")
	os.WriteFile(testFile1, []byte("#!/bin/bash\necho hello"), 0644)
	os.WriteFile(testFile2, []byte("test content"), 0644)

	req := httptest.NewRequest("GET", "/api/files", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleFiles)(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusOK)
	}

	var files []SyncFile
	if err := json.NewDecoder(rr.Body).Decode(&files); err != nil {
		t.Fatalf("Failed to decode response: %v", err)
	}

	if len(files) != 2 {
		t.Errorf("Got %d files, want 2", len(files))
	}
}

func TestHandleFilesUpload(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Create multipart form
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)
	part, _ := writer.CreateFormFile("file", "upload-test.sh")
	part.Write([]byte("#!/bin/bash\necho uploaded"))
	writer.Close()

	req := httptest.NewRequest("POST", "/api/files", &buf)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	req.Header.Set("Content-Type", writer.FormDataContentType())
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleFiles)(rr, req)

	if rr.Code != http.StatusCreated {
		t.Errorf("Got status %d, want %d. Body: %s", rr.Code, http.StatusCreated, rr.Body.String())
	}

	// Verify file exists
	uploadedPath := filepath.Join(server.syncDir, "upload-test.sh")
	if _, err := os.Stat(uploadedPath); os.IsNotExist(err) {
		t.Error("Uploaded file should exist")
	}
}

func TestHandleFilesDelete(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Create a file to delete
	testFile := filepath.Join(server.syncDir, "to-delete.txt")
	os.WriteFile(testFile, []byte("delete me"), 0644)

	req := httptest.NewRequest("DELETE", "/api/files?filename=to-delete.txt", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleFiles)(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusOK)
	}

	// Verify file is deleted
	if _, err := os.Stat(testFile); !os.IsNotExist(err) {
		t.Error("File should have been deleted")
	}
}

func TestHandleFilesDeleteNotFound(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	req := httptest.NewRequest("DELETE", "/api/files?filename=nonexistent.txt", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleFiles)(rr, req)

	if rr.Code != http.StatusNotFound {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusNotFound)
	}
}

func TestHandleFilesDeletePathTraversal(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Create a file outside sync dir
	outsideFile := filepath.Join(dataDir, "outside.txt")
	os.WriteFile(outsideFile, []byte("should not be deletable"), 0644)

	req := httptest.NewRequest("DELETE", "/api/files?filename=../outside.txt", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleFiles)(rr, req)

	// Should not delete file outside sync dir (filepath.Base sanitizes the path)
	if _, err := os.Stat(outsideFile); os.IsNotExist(err) {
		t.Error("File outside sync dir should not be deleted")
	}
}

// ==================== File Download Tests ====================

func TestHandleFileDownload(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Create a file
	content := "file content for download"
	testFile := filepath.Join(server.syncDir, "download-test.txt")
	os.WriteFile(testFile, []byte(content), 0644)

	req := httptest.NewRequest("GET", "/api/files/download?filename=download-test.txt", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleFileDownload)(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusOK)
	}

	if rr.Body.String() != content {
		t.Errorf("Got body %q, want %q", rr.Body.String(), content)
	}
}

// ==================== Result Logging Tests ====================

func TestLogResult(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	result := CommandResult{
		AgentID:       "test-agent",
		CommandID:     "cmd-1",
		Command:       "echo hello",
		Stdout:        "hello\n",
		Stderr:        "",
		ReturnCode:    0,
		StartTime:     "2024-01-15T10:30:00Z",
		ExecutionTime: 0.125,
	}

	server.logResult(result)

	// Close the gzip writer to flush
	server.gzWriter.Close()
	server.resultLog.Close()

	// Read and decompress the log
	logPath := filepath.Join(dataDir, "results.json.gz")
	f, err := os.Open(logPath)
	if err != nil {
		t.Fatalf("Failed to open log: %v", err)
	}
	defer f.Close()

	gzReader, err := gzip.NewReader(f)
	if err != nil {
		t.Fatalf("Failed to create gzip reader: %v", err)
	}
	defer gzReader.Close()

	data, err := io.ReadAll(gzReader)
	if err != nil {
		t.Fatalf("Failed to read log: %v", err)
	}

	var logged CommandResult
	if err := json.Unmarshal(bytes.TrimSpace(data), &logged); err != nil {
		t.Fatalf("Failed to parse logged result: %v", err)
	}

	if logged.AgentID != "test-agent" {
		t.Errorf("AgentID not logged correctly: got %q", logged.AgentID)
	}

	if logged.ReturnCode != 0 {
		t.Errorf("ReturnCode not logged correctly: got %d", logged.ReturnCode)
	}
}

// ==================== Agent State Tests ====================

func TestNewAgent(t *testing.T) {
	syncDir, _ := os.MkdirTemp("", "agent-sync-*")
	defer os.RemoveAll(syncDir)

	agent := NewAgent("http://localhost:8080", "test-token", "", syncDir)

	// Should default to hostname
	hostname, _ := os.Hostname()
	if agent.id != hostname {
		t.Errorf("Agent ID should default to hostname %q, got %q", hostname, agent.id)
	}

	if agent.serverURL != "http://localhost:8080" {
		t.Errorf("Server URL not set correctly: got %q", agent.serverURL)
	}
}

func TestNewAgentCustomID(t *testing.T) {
	syncDir, _ := os.MkdirTemp("", "agent-sync-*")
	defer os.RemoveAll(syncDir)

	agent := NewAgent("http://localhost:8080", "test-token", "custom-agent-id", syncDir)

	if agent.id != "custom-agent-id" {
		t.Errorf("Custom agent ID not set: got %q", agent.id)
	}
}

func TestAgentShouldRunCommand(t *testing.T) {
	syncDir, _ := os.MkdirTemp("", "agent-sync-*")
	defer os.RemoveAll(syncDir)

	agent := NewAgent("http://localhost:8080", "test-token", "test", syncDir)

	cmd := Command{
		ID:          "test-cmd",
		Command:     "echo test",
		IntervalSec: 60,
		OS:          "all",
	}

	// First run should be allowed
	if !agent.shouldRunCommand(cmd) {
		t.Error("First run should be allowed")
	}

	// Mark as run
	agent.lastRunMu.Lock()
	agent.lastRun[cmd.ID] = time.Now()
	agent.lastRunMu.Unlock()

	// Immediate second run should not be allowed
	if agent.shouldRunCommand(cmd) {
		t.Error("Immediate re-run should not be allowed")
	}

	// After interval passes, should be allowed
	agent.lastRunMu.Lock()
	agent.lastRun[cmd.ID] = time.Now().Add(-61 * time.Second)
	agent.lastRunMu.Unlock()

	if !agent.shouldRunCommand(cmd) {
		t.Error("Run after interval should be allowed")
	}
}

func TestAgentShouldRunCommandOSFiltering(t *testing.T) {
	syncDir, _ := os.MkdirTemp("", "agent-sync-*")
	defer os.RemoveAll(syncDir)

	agent := NewAgent("http://localhost:8080", "test-token", "test", syncDir)

	testCases := []struct {
		cmdOS    string
		expected bool
	}{
		{"all", true},
		{"linux", true},   // Assuming tests run on Linux
		{"windows", false}, // Assuming tests don't run on Windows
	}

	// Skip OS-specific tests if we can't determine OS
	currentOS := "linux" // Test assumption

	for _, tc := range testCases {
		cmd := Command{ID: "cmd-" + tc.cmdOS, IntervalSec: 60, OS: tc.cmdOS}
		result := agent.shouldRunCommand(cmd)

		// Only check if our assumption about running on Linux is correct
		if tc.cmdOS == "all" && !result {
			t.Error("OS 'all' should always match")
		}
		if tc.cmdOS == currentOS && !result {
			t.Errorf("OS %q should match current OS", tc.cmdOS)
		}
	}
}

func TestAgentSaveFile(t *testing.T) {
	syncDir, _ := os.MkdirTemp("", "agent-sync-*")
	defer os.RemoveAll(syncDir)

	agent := NewAgent("http://localhost:8080", "test-token", "test", syncDir)

	content := "test file content"
	b64Content := base64.StdEncoding.EncodeToString([]byte(content))

	agent.saveFile("saved-file.txt", b64Content)

	// Verify file was saved
	savedPath := filepath.Join(syncDir, "saved-file.txt")
	data, err := os.ReadFile(savedPath)
	if err != nil {
		t.Fatalf("Failed to read saved file: %v", err)
	}

	if string(data) != content {
		t.Errorf("File content mismatch: got %q, want %q", string(data), content)
	}
}

func TestAgentSaveFilePathTraversal(t *testing.T) {
	syncDir, _ := os.MkdirTemp("", "agent-sync-*")
	defer os.RemoveAll(syncDir)

	agent := NewAgent("http://localhost:8080", "test-token", "test", syncDir)

	content := "malicious content"
	b64Content := base64.StdEncoding.EncodeToString([]byte(content))

	// Try path traversal
	agent.saveFile("../../../etc/malicious.txt", b64Content)

	// File should be saved in sync dir with sanitized name
	savedPath := filepath.Join(syncDir, "malicious.txt")
	if _, err := os.Stat(savedPath); os.IsNotExist(err) {
		t.Error("File should be saved with sanitized name")
	}
}

// ==================== WebSocket Integration Tests ====================

func TestWebSocketAgentConnection(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	// Start test HTTP server
	mux := http.NewServeMux()
	mux.HandleFunc("/ws/agent", server.handleAgentWS)
	httpServer := httptest.NewServer(mux)
	defer httpServer.Close()

	// Connect as agent
	wsURL := "ws" + strings.TrimPrefix(httpServer.URL, "http") +
		"/ws/agent?agent_token=test-agent-token&agent_id=test-agent&os=linux"

	conn, _, err := websocket.DefaultDialer.Dial(wsURL, nil)
	if err != nil {
		t.Fatalf("Failed to connect: %v", err)
	}
	defer conn.Close()

	// Wait for agent to be registered
	time.Sleep(100 * time.Millisecond)

	server.agentsMu.RLock()
	agent, exists := server.agents["test-agent"]
	server.agentsMu.RUnlock()

	if !exists {
		t.Fatal("Agent should be registered")
	}

	if !agent.Connected {
		t.Error("Agent should be connected")
	}

	if agent.OS != "linux" {
		t.Errorf("Agent OS should be 'linux', got %q", agent.OS)
	}
}

func TestWebSocketAgentInvalidToken(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	mux := http.NewServeMux()
	mux.HandleFunc("/ws/agent", server.handleAgentWS)
	httpServer := httptest.NewServer(mux)
	defer httpServer.Close()

	// Try to connect with invalid token
	wsURL := "ws" + strings.TrimPrefix(httpServer.URL, "http") +
		"/ws/agent?agent_token=wrong-token&agent_id=test-agent&os=linux"

	_, resp, err := websocket.DefaultDialer.Dial(wsURL, nil)
	if err == nil {
		t.Fatal("Connection should have failed with invalid token")
	}

	if resp != nil && resp.StatusCode != http.StatusUnauthorized {
		t.Errorf("Expected 401 Unauthorized, got %d", resp.StatusCode)
	}
}

func TestWebSocketCommandBroadcast(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	mux := http.NewServeMux()
	mux.HandleFunc("/ws/agent", server.handleAgentWS)
	httpServer := httptest.NewServer(mux)
	defer httpServer.Close()

	// Connect as agent
	wsURL := "ws" + strings.TrimPrefix(httpServer.URL, "http") +
		"/ws/agent?agent_token=test-agent-token&agent_id=test-agent&os=linux"

	conn, _, err := websocket.DefaultDialer.Dial(wsURL, nil)
	if err != nil {
		t.Fatalf("Failed to connect: %v", err)
	}
	defer conn.Close()

	// Read initial commands message
	var receivedCommands bool
	done := make(chan bool)

	go func() {
		for {
			_, message, err := conn.ReadMessage()
			if err != nil {
				return
			}

			var msg WSMessage
			if err := json.Unmarshal(message, &msg); err != nil {
				continue
			}

			if msg.Type == "commands" {
				receivedCommands = true
				done <- true
				return
			}
		}
	}()

	select {
	case <-done:
		if !receivedCommands {
			t.Error("Should have received commands message")
		}
	case <-time.After(2 * time.Second):
		t.Error("Timeout waiting for commands message")
	}
}

// ==================== Concurrent Access Tests ====================

func TestConcurrentCommandAccess(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	var wg sync.WaitGroup
	errors := make(chan error, 100)

	// Concurrent writes
	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func(n int) {
			defer wg.Done()
			cmd := Command{
				ID:          string(rune('a' + n%26)) + string(rune('0'+n)),
				Command:     "echo test",
				IntervalSec: 60,
			}
			server.commandsMu.Lock()
			server.commands[cmd.ID] = cmd
			server.commandsMu.Unlock()
		}(i)
	}

	// Concurrent reads
	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			server.commandsMu.RLock()
			_ = len(server.commands)
			server.commandsMu.RUnlock()
		}()
	}

	wg.Wait()
	close(errors)

	for err := range errors {
		t.Errorf("Concurrent access error: %v", err)
	}
}

func TestConcurrentAgentAccess(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	var wg sync.WaitGroup

	// Concurrent agent registration
	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func(n int) {
			defer wg.Done()
			agent := &Agent{
				ID:        string(rune('a' + n%26)),
				OS:        "linux",
				Connected: true,
			}
			server.agentsMu.Lock()
			server.agents[agent.ID] = agent
			server.agentsMu.Unlock()
		}(i)
	}

	// Concurrent agent listing
	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			server.agentsMu.RLock()
			_ = len(server.agents)
			server.agentsMu.RUnlock()
		}()
	}

	wg.Wait()
}

// ==================== Edge Case Tests ====================

func TestEmptyCommandList(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	req := httptest.NewRequest("GET", "/api/commands", nil)
	req.Header.Set("Authorization", "Bearer test-admin-token")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	var commands []Command
	json.NewDecoder(rr.Body).Decode(&commands)

	if commands == nil {
		t.Error("Should return empty array, not nil")
	}

	if len(commands) != 0 {
		t.Errorf("Should return empty array, got %d commands", len(commands))
	}
}

func TestInvalidJSONBody(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	req := httptest.NewRequest("POST", "/api/commands", strings.NewReader("not valid json"))
	req.Header.Set("Authorization", "Bearer test-admin-token")
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	server.adminAuth(server.handleCommands)(rr, req)

	if rr.Code != http.StatusBadRequest {
		t.Errorf("Got status %d, want %d", rr.Code, http.StatusBadRequest)
	}
}

func TestListSyncFilesEmptyDir(t *testing.T) {
	server, dataDir := setupTestServer(t)
	defer cleanupTestServer(t, dataDir)

	files := server.listSyncFiles()

	if files == nil {
		t.Error("Should return empty slice, not nil")
	}

	if len(files) != 0 {
		t.Errorf("Should return empty slice, got %d files", len(files))
	}
}

// ==================== Benchmark Tests ====================

func BenchmarkGenerateToken(b *testing.B) {
	for i := 0; i < b.N; i++ {
		generateToken()
	}
}

func BenchmarkNowISO8601(b *testing.B) {
	for i := 0; i < b.N; i++ {
		nowISO8601()
	}
}

func BenchmarkCommandLookup(b *testing.B) {
	server, dataDir := setupTestServer(&testing.T{})
	defer os.RemoveAll(dataDir)

	// Add many commands
	for i := 0; i < 1000; i++ {
		cmd := Command{
			ID:          generateToken()[:16],
			Command:     "echo test",
			IntervalSec: 60,
		}
		server.commands[cmd.ID] = cmd
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		server.commandsMu.RLock()
		_ = len(server.commands)
		server.commandsMu.RUnlock()
	}
}
